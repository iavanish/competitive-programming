<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>
A regular bracket sequence is a sequence of opening ("(") and closing (")") brackets such that it is possible to obtain a correct mathematical expression from it by inserting numbers and operators between the brackets. For example, the sequences "(())()" and "()" are regular bracket sequences while sequences such as ")()" and "(()" are not.
</p>
<p>
A string is said to be <i>valid</i> if for each of its non-empty prefixes the number of opening brackets &gt;= number of closing brackets. For example, "((()()" and "(())" are valid strings but ")(" is not.
</p>
<p>
T[a..b] denotes the substring of T formed by characters at 0-based indices a through b, inclusive.
E.g., if T = "qwertyuiop" then T[2..5] = "erty".
</p>
<br></br>

<p>
You are given a regular bracket sequence <b>S</b> of length N.
Your goal is to change <b>S</b> into the lexicographically smallest regular bracket sequence possible.
Below we define the meaning of an operation.
You have to find any sequence of at most 300 operations that reaches your goal.
</p>
<p>
An operation looks as follows:
</p>
<ol>
<li>Choose a triplet of indices (a,b,c) such that 0 &lt;= a &lt;= b &lt; c &lt;= N-1 and that both substrings S[a..b] and S[b+1..c] are valid strings (as defined above).</li>
<li>Swap the substrings S[a..b] and S[b+1..c].</li>
</ol>
<p>
Lets say the number of operations you needed is X. Then return a int[] res with 3*X elements, where for i-th operation (a, b, c) we have res[3*i]=a, res[3*i+1]=b and res[3*i+2]=c respectively. 
</p>

</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>SmallestRegular</td></tr><tr><td>Method:</td><td>findLexSmallest</td></tr><tr><td>Parameters:</td><td>String</td></tr><tr><td>Returns:</td><td>int[]</td></tr><tr><td>Method signature:</td><td>int[] findLexSmallest(String S)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Notes</h3></td></tr><tr><td align="center" valign="top">-</td><td>For the purpose of the lexicographic ordering of bracket sequences, the character '(' is smaller than the character ')'.</td></tr><tr><td align="center" valign="top">-</td><td>You are not required to minimize the number of operations. Any valid solution will be accepted.</td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td>S will consist of characters '(' and ')' only.</td></tr><tr><td align="center" valign="top">-</td><td>S.length will be between 2 and 500, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>S.length will be even.</td></tr><tr><td align="center" valign="top">-</td><td>S will be a regular bracket sequence.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;(())&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: { }</pre></td></tr><tr><td><table><tr><td colspan="2">Here we can see that <b>S</b> is already lexicographically smallest.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;(()())&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: {1, 2, 3 }</pre></td></tr><tr><td><table><tr><td colspan="2">Here after performing operation (1, 2, 3), we obtain <b>S</b> = "((()))" which is the lexicographically smallest S we can obtain.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>&quot;()()()()&quot;</pre></td></tr></table></td></tr><tr><td><pre>Returns: {2, 3, 6, 2, 3, 5, 0, 1, 4 }</pre></td></tr><tr><td><table><tr><td colspan="2"><p>
Here after preforming the first operation (2, 3, 6), we obtain <b>S</b> = "()()(())".
</p>
<p>
Now after second operation (2, 3, 5), we obtain <b>S</b> = "()((()))".
</p>
<p>
After third operation (0, 1, 4), we obtain <b>S</b> = "(((())))".
</p></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>